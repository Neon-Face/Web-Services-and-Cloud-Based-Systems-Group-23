# Implementation Report – URL Shortener Service

>Group 23
## 1. Implementation Overview

This report outlines the design and implementation of a RESTful URL shortener service. The service provides the ability to create, retrieve, and delete shortened URLs while ensuring uniqueness, efficiency, and scalability. The implementation follows REST principles and employs a Snowflake ID generator for unique and efficient ID creation, Base62 encoding for compact representation, and regular expression-based validation to ensure only valid URLs are stored.
#### The API supports the following endpoints:

The implementation ensures proper error handling, concurrency management, and efficient ID generation while maintaining adherence to REST and CRUD principles.

| Endpoint      | Method | Functionality                               | Expected Response                                                                           |
| :------------ | :----- | :------------------------------------------ | :------------------------------------------------------------------------------------------ |
| $/<id>$       | GET    | Retrieves the full URL for a given short ID | 301 Redirect if found, 404 Not Found if missing                                             |
| $/<id>$       | PUT    | Updates an existing short ID with a new URL | 200 OK if successful, 400 Bad Request for invalid input, 404 Not Found if ID does not exist |
| $/<id>$       | DELETE | Deletes an existing short ID                | 204 No Content if successful, 404 Not Found if ID does not exist                            |
| $/$           | GET    | Lists all stored short IDs                  | 200 OK, returns all keys                                                                    |
| $/$           | POST   | Creates a new short URL                     | 201 Created, returns a new short ID, 400 Bad Request for invalid input                      |
| $/stats/<id>$ | GET    | Retrieves usage statistics for a short URL  | 200 OK with statistics if found, 404 Not Found if ID does not exist                         |
## 2. Snowflake ID Generation Algorithm

To handle high concurrency and ensure globally unique short URLs, the system employs a Snowflake ID generator. This algorithm produces 64-bit unique identifiers that encode a timestamp, a machine identifier, and a sequence number.
#### Structure of the Snowflake ID

1. Timestamp (41 bits) – Ensures uniqueness over time.
2. Machine ID (10 bits) – Differentiates IDs generated by different servers.
3. Sequence Number (12 bits) – Ensures uniqueness within the same millisecond.

By combining these components, the Snowflake ID generator guarantees that no two IDs are identical, even in a high-traffic system. The use of monotonic increasing timestamps also ensures that IDs remain sequential, improving indexing and lookup efficiency.
#### Concurrency and Thread Safety

Since multiple users may generate URLs simultaneously, the implementation employs threading locks (threading.Lock()) to prevent race conditions when updating the sequence number and timestamp. This ensures that each ID remains unique, even when requests arrive in parallel.
#### Advantages of the Snowflake Approach

- Collision-Free: Ensures that every generated ID is unique across distributed systems.
- Scalable: The structure allows multiple machines to generate IDs without coordination.
- Time-Ordered: The increasing timestamp component makes sorting and querying more efficient.
## 3. Base62 Encoding for Compact URLs

Once a numeric Snowflake ID is generated, it is converted into a short, alphanumeric string using Base62 encoding. Base62 uses a character set of 62 symbols (0-9, A-Z, a-z), ensuring that shortened URLs remain compact and URL-safe.

Rationale for Choosing Base62
- Shorter URLs: Base62 can encode large numbers using fewer characters, keeping URLs concise.
- Alphanumeric-Only: Unlike Base85 or higher bases, Base62 avoids special characters, ensuring compatibility across platforms and preventing encoding issues.
- Scalability: The large character space reduces the risk of collisions as the number of stored URLs increases.
- Although Base58 removes visually similar characters (0, O, I, l) to improve readability, Base62 provides better compression while maintaining an intuitive format. Base85, while offering even greater compression, introduces special characters that could cause compatibility issues with browsers and APIs.
## 4. URL Validation Using Regular Expressions

To prevent storing malformed URLs, the system applies regular expression-based validation before accepting any input.
#### Regex Pattern Used

`^(https?:\/\/)?([\w\.-]+)\.([a-z]{2,6})([\/\w .\–#%()\[\]\'-]*)*\/?$`
#### Pattern Breakdown

| **Pattern**                | **Explanation**                                                                                                                                                                                                                   |
| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `^`                        | Marks the start of the string, ensuring the match begins at the beginning of the input.                                                                                                                                           |
| `(https?:\/\/)?`           | Matches "http://" or "https://". <br> - `https?` allows both "http" and "https". <br> - `:\/\/` matches "://", escaping special characters. <br> - `?` makes the protocol optional.                                               |
| `([\w\.-]+)`               | Matches the domain name (excluding the top-level domain). <br> - `\w` matches letters, digits, and underscores. <br> - `.` and `-` are allowed in domain names. <br> - `+` ensures at least one character is present.             |
| `\.`                       | Matches a literal period (`.`) between the domain and the top-level domain (TLD).                                                                                                                                                 |
| `([a-z]{2,6})`             | Matches the TLD (e.g., `.com`, `.org`). <br> - `[a-z]` ensures only lowercase letters. <br> - `{2,6}` limits the length to 2-6 characters.                                                                                        |
| `([\/\w .–#%()\[\]\'-]*)*` | Matches the optional URL path, query parameters, and fragments. <br> - Includes `/`, letters, digits, spaces, and special characters such as `.`, `#`, `%`, `()`, `[]`, `'`, and `-`. <br> - `*` allows zero or more occurrences. |
| `\/?`                      | Matches an optional trailing slash (`/`).                                                                                                                                                                                         |
| `$`                        | Marks the end of the string to ensure the entire input conforms to the pattern.                                                                                                                                                   |
| `re.UNICODE`               | Enables Unicode support, allowing validation of international domain names.                                                                                                                                                       |
## 5. Multi-User URL Shortener Design (Future Implementation)

To extend the system for multi-user functionality, additional features would be required:

 1. Authentication: Users would authenticate via API keys, OAuth, or JWT tokens to ensure URL ownership.
 2. Database Storage: URLs would be stored in PostgreSQL, MySQL, or Redis, allowing persistent data and user-based queries.
 3. Access Control: Users would only be able to edit or delete their own URLs, preventing unauthorized modifications.
 4. By integrating authentication and database storage, the system could support millions of users securely and efficiently.
## 6.Additional Features and /stats Endpoint

The service includes a $/stats/<id>$ endpoint that allows users to retrieve usage statistics for each shortened URL. This endpoint returns data such as:

- Total Clicks: The number of times the shortened URL was accessed.
- Last Accessed Timestamp: The most recent time the URL was visited.
- Creation Timestamp: The time the short URL was generated.
- This feature provides valuable insights into URL usage and can be extended to track user demographics, referrer data, and geolocation analytics in a full-scale deployment.
## 7. Contribution Breakdown

| Team Member | Contribution                                                                                                                          |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| Michiel     | - Implemented Snowflake ID and Base62 encoding                                                                                        |
| Zifeng Ma   | - Wrote regex validation and handled concurrency issues and drafted report                                                            |
| Jay         | - Developed initial Flask code and first  tested endpoints<br>- Integrated /stats endpoint and finished report<br>- Wrote README file |
*While tasks were divided, all members collaborated on debugging, testing, and refining the implementation.*
## 8. Conclusion

This project successfully implements a scalable, efficient URL shortening service using a Snowflake ID generator, Base62 encoding, and URL validation. The system supports high-concurrency access, ensures uniqueness, and provides insightful analytics through the /stats endpoint.
Future improvements could include user authentication, persistent database storage, and custom short links to expand functionality. By following RESTful design principles and best practices, the service is well-equipped for real-world deployment and large-scale use.
